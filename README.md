[![Travis-CI Build Status](https://travis-ci.org/arendsee/fagin.svg?branch=dev)](https://travis-ci.org/arendsee/fagin)
[![Coverage Status](https://img.shields.io/codecov/c/github/arendsee/fagin/master.svg)](https://codecov.io/github/arendsee/fagin?branch=dev)

# Fagin

A pipeline for the classification of orphans into origin classes using a syntenic filter.

## Funding

This work is funded by the National Science Foundation grant:

[NSF-IOS 1546858](https://www.nsf.gov/awardsearch/showAward?AWD_ID=1546858)
Orphan Genes: An Untapped Genetic Reservoir of Novel Traits

## Installation

```R
devtools::install_github("arendsee/fagin")
library(fagin)
```

## Dependencies

Currently `fagin` has no dependencies outside of R. It makes heavy use of
bioconductor (e.g. `Biostring`, `GenomicRanges`, and `GenomicFeatures`). It
also uses the rather experimental packages 'synder' and 'rmonad'.

## Input

The following is required

 - Phylogeny for all included species
 - Name of the focal species
 - Synteny map for the focal species versus each other species
 
   Synteny format as below (without header):
 ```diff
 ! start coordinate should be always smaller than end even if the orientation is -
 ! use tab as delimiter
 - query_chromosome   query_start   query_end    focal_chromosome   focal_start  focal_end  orientation
 ```
 ```
 glyma.Wm82.gnm4.Gm01    21959   38456   glyso.PI483463.gnm1.Gs01        36820   53293   99.33   +
 glyma.Wm82.gnm4.Gm01    38578   65125   glyso.PI483463.gnm1.Gs01        53292   79843   99.60   +
 glyma.Wm82.gnm4.Gm01    31089362        31107279        glyso.PI483463.gnm1.Gs06        26698042        26715972        99.30   -
 glyma.Wm82.gnm4.Gm01    31113843        31161139        glyso.PI483463.gnm1.Gs06        26643559        26690868        99.02   -
 ```
 - For each species
   - GFF file (must at least include gene models)
   - Full genome (GFF reference)
 - Query and control gene list (should use the name but not the ID of mRNA in GFF file)
```diff
! Important notes:
! Chromosome ID in GFF, fna, and syn files should be consistent.
! Chromosomes or scaffolds in GFF, fna, and syn files should be same. 
! If there are more chromosome or scaffold in any file than other file, you may get error like this:
# "subscript out of bounds"
! You may need to request large memory to run the program
```
   
 

## Documentation

Go [here](https://github.com/arendsee/fagin-case-studies) to see working case
studies that you can adapt for your own projects.

You can also check out the (under construction) wiki [here](https://github.com/arendsee/fagin/wiki).

## Configuration

To run and configure `fagin`, you need to set paths to your data in
a configuration object. The default configuration can be generated

```R
config()
```

Soybean example to generate a configuration object:

```R
library(fagin)
library(rmonad)
library(knitr)
library(magrittr)
library(readr)
library(ggplot2)

get_soybean_config <- function(){
  con <- fagin::config()
  con@archive = "glymax-archive"
  con@synder@offsets = c(1L,1L) # offsets for synteny map generated by mummer
  con@synder@trans = "p" # proportion transform mummer
  con@alignment@dna2dna_maxspace = 1e8L
  con@input@focal_species = "Glycine_max_v4"
  con@input@gff <- list(
    "Glycine_max_v4"   = "10.29_glyma.Wm82.v4.gff" # path of the gff file
    , "Glycine_max_v2" = "10.29_glyma.Wm82.v2.gff"
    , "Glycine_max_Lee" = "10.29_glyma.Lee.gff"
    , "Glycine_soja"  = "10.29_glyso.PI483463.gff"
  )
  con@input@fna <- list(
    "Glycine_max_v4"   = "10.29_glyma.Wm82.v4.fna" # path of the genome sequence file
    , "Glycine_max_v2" = "10.29_glyma.Wm82.v2.fna"
    , "Glycine_max_Lee" = "10.29_glyma.Lee.fna"
    , "Glycine_soja"  = "10.29_glyso.PI483463.fna"
  )
  con@input@syn <- list(
    "Glycine_max_v2" = "10.29_Gmax2.0_Wm82.gnm4.syn" # path of the synteny map file
    , "Glycine_max_Lee" = "10.29_GlymaLee_Wm82.gnm4.syn"
    , "Glycine_soja" = "10.29_Glyso.pi483463_Wm82_gnm4.syn"  
  )
  con@input@tree <- "tree" # path of phylogeny tree
  con@input@query_gene_list <- "10.31_query.txt" # path of query gene list
  con@input@control_gene_list <- "10.31_control.txt" # path of control gene list
  fagin::validate_config(con)
  con
}

con <- get_soybean_config()
```


This will need to be tailored to your specific needs. To run the full fagin analysis, call

```R
# Where con is your configuration object
m <- run_fagin(con)
```

## Output

In order to get homolog class, you can extract information from `m` using the code as below:

```R
rbind_with_name <- function(xs, grpname){
  for(name in names(xs)){
    xs[[name]][[grpname]] <- name
  }
  out <- do.call(rbind, xs)
  rownames(out) <- NULL
  out
}

# convert the group labels corresponding to the fagin paper
name_conversion <-  c(O1="A_gen", O2="A_trn", O3="A_orf",
                      N1="N_cds", N2="N_exo", N3="N_rna", N4="N_dna",
                      U2="U_ind", U5="U_scr", U6="U_unk", U1="U_una", U3="U_nst", U7="U_tec")

# function to clean the species name
clean_name <- function(x, suffix){
  x$target_species <- sub(suffix, "", x$target_species)
  x
}

# determine the homolog feature for each gene as figure 3 in fagin paper 
# feature_table is a list of dataframes for the homolog class of query and control genes against the target species.
# the following code combine the list into a single dataframe.
feats <- get_value(m, tag='feature_table') %>%
  rbind_with_name("target_species") %>%
  clean_name("feature_table/query/") %>% 
  clean_name("feature_table/control/")
  
# load phylostrata levels for query and control gene list
# see phylostratr pacakge for the format
strata <- readr::read_tsv("10.31_strata.tab")

# classify homolog group for query gene list

id_query <- get_value(m, tag='query_genes')[[1]]

#subset strata for query genes and rename the column names
query <- subset(strata, seqid %in% id_query) %>%
  dplyr::select(seqid, std_strata_name = mrca, std_strata_level = ps)

#query_labels is a list for the genes group as Fig.5 in paper. Include 3 list, tree, labels, and summary
#tree: relation as Fig.3 in fagin paper.
#labels: a list of dataframes of groups for each species. 
#summary: counts of genes by groups and species. This is the data for Fig.5 without grouping by gene age.
vs_query <- get_value(m, tag='query_labels')[[1]]

#combine the list of vs_query to a single dataframe, and convert the group name same as the name in paper (fig.5)
labels_query <- rbind_with_name(vs_query$labels, "target_species") %>%
  dplyr::select(seqid, homology_class=secondary, target_species) %>%
  dplyr::mutate(homology_class = name_conversion[homology_class])

#merge the query gene groups by fagin and the phylostratra levels
query <- merge(query, labels_query, by='seqid')
query <- merge(query, feats, by=c("seqid", "target_species"))

#query_origins is a list of dataframes for the rules in fig.4. Include root, backbone, classStr, and classSum
#root is your input tree for the species.
#backbone is the gene classification for each query gene for each clade as fig.4
#classStr is the final gene classification for each query gene as fig.4
#classSum is the frequency for each classification.
ori_query <- get_value(m, tag="query_origins")[[1]]$backbone
ori_query <- as.matrix(ori_query)
ori_query[ori_query == "O"] <- "A"
ori_query <- as.data.frame(ori_query)
ori_query$seqid <- rownames(ori_query)

#combine two classification result
query <- merge(query, ori_query, by='seqid')
query$group = "query"

# classify homolog group for control gene list
id_control <- get_value(m, tag='control_genes')[[1]]

control <- subset(strata, seqid %in% id_control) %>%
  dplyr::select(seqid, std_strata_name = mrca, std_strata_level = ps)

vs_control <- get_value(m, tag='control_labels')[[1]]


labels_control <- rbind_with_name(vs_control$labels, "target_species") %>%
  dplyr::select(seqid, homology_class=secondary, target_species) %>%
  dplyr::mutate(homology_class = name_conversion[homology_class])

control <- merge(control, labels_control, by='seqid')

control <- merge(control, feats, by=c("seqid", "target_species"))

ori_control <- get_value(m, tag="control_origins")[[1]]$backbone
ori_control <- as.matrix(ori_control)
ori_control[ori_control == "O"] <- "A"
ori_control <- as.data.frame(ori_control)
ori_control$seqid <- rownames(ori_control)

control <- merge(control, ori_control, by='seqid')
control$group = "control"

# combine query gene and control gene result into a dataframe
fagin_result <- rbind(query, control)

# barplot for homolog class as figure 5 in fagin paper
ggplot(fagin_result, aes(x=homology_class, fill=target_species)) +
  geom_bar(stat="count", position=position_dodge()) +
  facet_grid(std_strata_name ~ .) +
  theme_classic() 
```


## Pipeline

 - Identify target genes that overlap the search space.
 - Search the query protein against the overlapping target gene's ORFs
 - Search the query gene DNA against the search interval DNA sequences
 - Predict ancestor states
